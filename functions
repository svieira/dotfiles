# vim: set filetype=sh :
# Set the terminal emulator's title
title() {
    echo -ne "\033]0;"$*"\007"
}

# Simpler ssh tunnels
# tunnel some.host:8080 :9090
# tunnel another.host:5000 local.dev.host:8080
tunnel() {
    local remoteHost=${1/:*/}
    local remotePort=${1/*:/}
    local localHost=${2/:*/}
    local localPort=${2/*:/}

    localHost=${localHost:-localhost}
    echo "Mapping $remoteHost:$remotePort to $localHost:$localPort"

    ssh -N -L $localPort:${localHost}:$remotePort $remoteHost
}

current_date() {
    date +${1:-%Y-%m-%d}
}

current_time() {
    date +${1:-%H:%M:%S}
}

notify() {
  local SCRIPT_NAME=$FUNCNAME
  local HELP=

  read -rd '' HELP << HELP
$SCRIPT_NAME
Put a notification in the notification center
(requires terminal-notifier)

Usage:

$SCRIPT_NAME
  -m | --message msg          - The message to display in the notification
  [-i | --icon  name]         - The name of the icon to display
                                (default: Terminal)
  [-t | --title title]        - The title to display for the notification
                                (default: Terminal)
  [...notifier-args]          - Additional arguments for terminal-notifier
HELP

  local notifier_args=
  local icon=
  local title=
  local message=

  while [ "${1+defined}" ]; do
    case $1 in
      -h|--help) echo "$HELP" && return 0;;
      -i|--icon) icon="$2"; shift;;
      -m|--message) message="$2"; shift;;
      -t|--title) title="$2"; shift;;
      *) notifier_args+="$1 ";;
    esac
    shift
  done

  if [ -n "$icon" ]; then
    [[ ! "$icon" =~ ^(~|/) ]] && icon=~/Pictures/icons/$icon
    [[ ! "$icon" =~ \.png$ ]] && icon=${icon}.png
  fi
  echo $notifier_args
  terminal-notifier -message "$message" ${title:+-title "$title"} ${icon:+-appIcon "$icon"} $notifier_args
}

notify-complete() {
  ( "${@}" )
  local status=$?
  if [ $status -eq 0 ]; then
    notify --message "Ran ${*}"
  else
    notify --message "Failed to run ${*}" --title "Exit status: $status"
  fi
}

# assign variableName command --string here
# echo $variableName
# Via http://stackoverflow.com/a/21636953/135978
assign() {
    local var=$1; shift;
    local channel=/tmp/assignfifo-${BASH_PID}-${BASH_SUBSHELL}
    mkfifo $channel
    exec 3<> $channel
    "$@" 1>&3
    local result=$?
    if [[ $result -eq 0 ]];
        then read -u3 ${var}
    fi
    exec 3>&-
    rm $channel
    return $result
}

# Save a few keystrokes
docker-startup() {
    boot2docker start
    # Disable assign for now until I make it more robust
    # assign DOCKER_HOST boot2docker shellinit
    # export DOCKER_HOST=${DOCKER_HOST##*=}
    export DOCKER_CERT_PATH=/Users/sean/.docker/boot2docker-vm
    export DOCKER_HOST=tcp://192.168.59.103:2376
    export DOCKER_TLS_VERIFY=1
}

docker-shutdown() {
    boot2docker stop
}

# Use clipboard in shell pipelines
# clip | xargs echo           # uses pbpaste
# ps -A | grep search | clip  # uses pbcopy
clip() {
  [ -t 0 ] && pbpaste || pbcopy
}

# Get the absolute path of a file or directory
# Via: http://stackoverflow.com/a/23002317/135978
abspath() {
   # $1 : relative filename
   if [ -d "$1" ]; then
     # dir
     echo $(cd "$1"; pwd)
   elif [ -f "$1" ]; then
     # file
     if [[ $1 == */* ]]; then
       echo $(cd "${1%/*}"; pwd)/${1##*/}
     else
       echo $(pwd)/$1
     fi
   fi
}

# Bookmark a directory so you can `cd {bookmark-name}` to it from anywhere
bmd() {
  local directory=`abspath ${1:-.}`
  local bookmark_name=${2:-${directory##*/}}
  ln -si $directory $CDPATH/$bookmark_name
}

# For those times when you need to wrap `set -e` around just *one* command.
try-or-fail() {
  eval "$@"
  local status=$?
  [ $status -ne 0 ] && echo "Failed to execute $@" && exit $status
}

confirm() {
    local msg=${1:-Are you sure}
    local choice=
    read -r -n 1 -p "$msg [y/N]? " choice
    echo
    case "$choice" in
      y*|Y* ) return 0;;
      * ) return 1;;
    esac
}

pause() {
  local ignored
  read -s -r -p "Press any key to continue..." -n 1 ignored
}

error() {
  echo >&2 $@
}

fail() {
  error $@
  exit 1
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
# VIA: https://github.com/mathiasbynens/dotfiles/blob/287f38e2196d8367cf2cb33b6f75860dbf17492a/.functions#L240-246
tre() {
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

# history with grep
#
# history list
# history <filter> greped history
# Taken from humanism.sh
history() {
    if [ $# -eq 0 ]; then
      builtin history
    else
      builtin history | grep $@
    fi
}

update() {
    if command -v update_start; then update_start; fi
    brew update && brew upgrade --all
    for venv in $PIPSI_HOME/*; do
        echo Upgrading pip in $venv
        . $venv/bin/activate && pip install --upgrade pip && deactivate
    done
    pipsi upgrade pipsi
    for package in $(pipsi list | sed -ne 's/^.*Package "\(.*\)".*/\1/p' | grep -v pipsi); do
        echo pipsi upgrade "$package"
        pipsi upgrade "$package"
    done
    if [[ "$1" == "--all" ]]; then
        boot2docker upgrade
        sudo softwareupdate --list
    fi
    if command -v update_local; then update_local; fi
}


if [ -f $CONFIGDIR/functions_local ]; then
  . $CONFIGDIR/functions_local
fi
